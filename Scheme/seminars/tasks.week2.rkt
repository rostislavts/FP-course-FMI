
(define (fact n)
  (define (for i result)
    (if (<= i n)
        (for (+ 1 i) (* result i))
          result ) )
  (for 1 1))

(define (fib n)
  (define (iter i firstN secondN)
    (if (< i n)
        (iter (+ 1 i) secondN (+ firstN secondN) )
        firstN )  )
  (iter 0 0 1) )

(define (sum-interval a b)
  (define (iter i result)
    (if (<= i b)
        (iter (+ i 1) (+ i result) )
        result) )
  (iter a 0))

(define (digit-occurance d n)
  (define (iter result currN)
    (if (> currN 0)
        (if (= (remainder currN 10) d)
            (iter (+ 1 result) (quotient currN 10) )
            (iter result (quotient currN 10) ) )
        result) )
  (iter 0 n) )

(define (count-digits n)
  (define (abs x)
    (if (< x 0)
        (- x)
        x) )
  (define (iter result currN)
    (if (> currN 0)
        (iter (+ 1 result) (quotient currN 10) )
        result) )
  (if (= n 0)
      1
      (iter 0 (abs n) ) ))

(define (reverse-num n)
  (define sign
    (if (> n 0)
        1
        (- 1)) )
    (define (abs x)
    (if (< x 0)
        (- x)
        x) )
  (define (iter currN result)
    (if (> currN 0)
        (iter (quotient currN 10) (+ (* result 10) (remainder currN 10) ) )
        (* result sign)) )
  (iter (abs n) 0) )


(define (palindrome? n)
  (define (getDigitAt i)
     (remainder (quotient n (expt 10 (- (count-digits n) i) ) ) 10 ) )
  (define (iter idx)
    (if (< idx (- (count-digits n) (- idx 1)) )
        (if (= (getDigitAt idx) (getDigitAt (- (count-digits n) (- idx 1) ) ) )
            (iter (+ idx 1) )
            #f)
        #t) )
  (iter 1) )

(define (prime? n)
  (define (iter i)
    (if (< i (- n 1) )
        (if (= (remainder n i) 0)
            #f
            (iter (+ i 1)) )
        #t) )
  (iter 2))


(define (pow-it x n)
  (define (iter i result)
    (if (< i n)
        (iter (+ i 1) (* result x) )
        result) )
  (iter 0 1))
(define (fast-pow x n)
  (if (< n 0)
      (pow-it (/ 1 x) (- n) )
      (pow-it x n)) )

(define (bin-to-dec n)
  (define (iter i result currN)
    (if (> currN 0)
        (if (= (remainder currN 10) 1)
            (iter (+ i 1) (+ result (fast-pow 2 i) ) (quotient currN 10) )
            (iter (+ i 1) result (quotient currN 10) ) )
        result) )
  (iter 0 0 n) )

(define (dec-to-bin n)
  (define (iter i result currN)
    (if (> currN 0)
        (iter (+ i 1) (+ result (* (remainder currN 2) (fast-pow 10 i) )) (quotient currN 2) )
        result) )
  (iter 0 0 n) )


(define (subnum? num1 num2)
  (define (getDigitAt i num)
     (remainder (quotient num (expt 10 (- (count-digits num) i) ) ) 10 ) )
  (define (compare? idxOfNum2)
    (define (iter i idxNum2)
      (if (<= i (count-digits num1) )
          (if (= (getDigitAt idxNum2 num2) (getDigitAt i num1) )
              (iter (+ i 1) (+ idxNum2 1) )
              #f)
          #t) )
    (iter 1 idxOfNum2) )
  (define (out-iter idx)
    (if (<= idx (- (count-digits num2) (count-digits num1) (- 1) ) )
        (if (compare? idx)
            #t
            (out-iter (+ idx 1) ) )
        #f) )
  (out-iter 1) )

; RECURSIVELY

(define (palindrome-rec? n)
  (define (getDigitAt i)
     (remainder (quotient n (expt 10 (- (count-digits n) i) ) ) 10 ) )
  (define (hasMirrorDigits idx)
    (if (= (getDigitAt idx) (getDigitAt (- (count-digits n) (- idx 1) ) ) )
        0
        1) )
  (define (help idx)
    (if (< idx (- (count-digits n) (- idx 1)) )
            (+ (hasMirrorDigits idx) (help (+ idx 1) ))
            0) ) 
  (= (help 1) 0))


(define (prime-rec? n)
  (define (hasDivisor i)
    (if (= (remainder n i) 0)
        1
        0) )
  (define (help i)
    (if (< i (- n 1) )
        (+ (hasDivisor i) (help (+ i 1)) )
        0)) 
  (if (= (help 2) 0)
      #t
      #f))

